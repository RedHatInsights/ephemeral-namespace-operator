
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1/namespacepool_types.go (0.0%)</option>
				
				<option value="file1">github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1/namespacereservation_types.go (0.0%)</option>
				
				<option value="file2">github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file3">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/clowdenvironment_controller.go (70.2%)</option>
				
				<option value="file4">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers/clowdenvs.go (0.0%)</option>
				
				<option value="file5">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers/frontends.go (0.0%)</option>
				
				<option value="file6">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers/namespaces.go (0.0%)</option>
				
				<option value="file7">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers/pool.go (0.0%)</option>
				
				<option value="file8">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers/reservation.go (0.0%)</option>
				
				<option value="file9">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers/types.go (0.0%)</option>
				
				<option value="file10">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/metrics.go (100.0%)</option>
				
				<option value="file11">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/namespacepool_controller.go (82.7%)</option>
				
				<option value="file12">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/namespacereservation_controller.go (70.3%)</option>
				
				<option value="file13">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/poller.go (79.5%)</option>
				
				<option value="file14">github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/run.go (18.8%)</option>
				
				<option value="file15">github.com/RedHatInsights/ephemeral-namespace-operator/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        clowder "github.com/RedHatInsights/clowder/apis/cloud.redhat.com/v1alpha1"
        core "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NamespacePoolSpec defines the desired state of Pool
type NamespacePoolSpec struct {
        // Number of namespaces to have ready in the pool
        Size int `json:"size"`
        // Optional max number of namespaces for a pool
        SizeLimit *int `json:"sizeLimit,omitempty"`
        // Determine whether the project uses a project or a namespace
        Local bool `json:"local"`
        // Clowdenvironment template for the namespace
        ClowdEnvironment clowder.ClowdEnvironmentSpec `json:"clowdenvironment"`
        // Resource limits for containers and pods for the deployed namespace
        LimitRange core.LimitRange `json:"limitrange"`
        // Defined resource quotas for specific states for the deployed namespace
        ResourceQuotas core.ResourceQuotaList `json:"resourcequotas"`
        // Description for the namespace pool
        Description string `json:"description,omitempty"`
        // Contains a list of teams and corresponding secrets
        Teams []Team `json:"teams,omitempty"`
}

// Team defines options that alter ENO behavior depending on name of team making the reservation
type Team struct {
        Name    string        `json:"name"`
        Secrets []SecretsData `json:"secrets"`
}

type SecretsData struct {
        Name     string `json:"name"`
        DestName string `json:"destName,omitempty"`
}

// NamespacePoolStatus defines the observed state of Pool
type NamespacePoolStatus struct {
        Ready    int `json:"ready"`
        Creating int `json:"creating"`
        Reserved int `json:"reserved"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
//+kubebuilder:resource:scope=Cluster,shortName=nspool
//+kubebuilder:printcolumn:name="Pool Size",type="string",JSONPath=".spec.size"
//+kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready"
//+kubebuilder:printcolumn:name="Creating",type="string",JSONPath=".status.creating"

// NamespacePool is the Schema for the pools API
type NamespacePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   NamespacePoolSpec   `json:"spec,omitempty"`
        Status NamespacePoolStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// PoolList contains a list of Pool
type NamespacePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []NamespacePool `json:"items"`
}

func init() <span class="cov0" title="0">{
        SchemeBuilder.Register(&amp;NamespacePool{}, &amp;NamespacePoolList{})
}</span>

// MakeOwnerReference defines the owner reference pointing to the Pool resource.
func (i *NamespacePool) MakeOwnerReference() metav1.OwnerReference <span class="cov0" title="0">{
        return metav1.OwnerReference{
                APIVersion: i.APIVersion,
                Kind:       i.Kind,
                Name:       i.ObjectMeta.Name,
                UID:        i.ObjectMeta.UID,
                Controller: TruePtr(),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NamespaceReservationSpec defines the desired state of NamespaceReservation
type NamespaceReservationSpec struct {
        // Duration is how long the reservation will last
        Duration *string `json:"duration,omitempty"`
        // Requester is the entity (bot or human) requesting the namespace
        Requester string `json:"requester"`
        // contains a list of teams and corresponding secrets
        Team string `json:"team,omitempty"`
        // PoolType is the pool resource specified to reserve a namespace from
        // +kubebuilder:default:=default
        Pool string `json:"pool,omitempty"`
}

// NamespaceReservationStatus defines the observed state of NamespaceReservation
type NamespaceReservationStatus struct {
        // Expiration of reservation
        Expiration metav1.Time `json:"expiration"`
        // State determines whether a reservation is active, waiting, or in error
        State string `json:"state"`
        // Name of the namespace associated with the reservation
        Namespace string `json:"namespace"`
        // Specifies the pool type that the reservation was requested with
        Pool string `json:"pool,omitempty"`
}

//+kubebuilder:object:root=true
//+kubebuilder:subresource:status
//+kubebuilder:resource:scope=Cluster,shortName={reservation,nsr}
//+kubebuilder:printcolumn:name="Requester",type="string",JSONPath=".spec.requester"
//+kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.state"
//+kubebuilder:printcolumn:name="Namespace",type="string",JSONPath=".status.namespace"
//+kubebuilder:printcolumn:name="Expiration",type="string",format="date-time",JSONPath=".status.expiration"

// NamespaceReservation is the Schema for the namespacereservations API
type NamespaceReservation struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   NamespaceReservationSpec   `json:"spec,omitempty"`
        Status NamespaceReservationStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// NamespaceReservationList contains a list of NamespaceReservation
type NamespaceReservationList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []NamespaceReservation `json:"items"`
}

func init() <span class="cov0" title="0">{
        SchemeBuilder.Register(&amp;NamespaceReservation{}, &amp;NamespaceReservationList{})
}</span>

// MakeOwnerReference defines the owner reference pointing to the NamespaceReservation resource.
func (i *NamespaceReservation) MakeOwnerReference() metav1.OwnerReference <span class="cov0" title="0">{
        return metav1.OwnerReference{
                APIVersion: i.APIVersion,
                Kind:       i.Kind,
                Name:       i.ObjectMeta.Name,
                UID:        i.ObjectMeta.UID,
                Controller: TruePtr(),
        }
}</span>

// TruePtr returns a pointer to True
func TruePtr() *bool <span class="cov0" title="0">{
        t := true
        return &amp;t
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">//go:build !ignore_autogenerated

/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
        runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespacePool) DeepCopyInto(out *NamespacePool) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        out.Status = in.Status
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespacePool.
func (in *NamespacePool) DeepCopy() *NamespacePool <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespacePool)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NamespacePool) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespacePoolList) DeepCopyInto(out *NamespacePoolList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]NamespacePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespacePoolList.
func (in *NamespacePoolList) DeepCopy() *NamespacePoolList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespacePoolList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NamespacePoolList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespacePoolSpec) DeepCopyInto(out *NamespacePoolSpec) <span class="cov0" title="0">{
        *out = *in
        if in.SizeLimit != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SizeLimit, &amp;out.SizeLimit
                *out = new(int)
                **out = **in
        }</span>
        <span class="cov0" title="0">in.ClowdEnvironment.DeepCopyInto(&amp;out.ClowdEnvironment)
        in.LimitRange.DeepCopyInto(&amp;out.LimitRange)
        in.ResourceQuotas.DeepCopyInto(&amp;out.ResourceQuotas)
        if in.Teams != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Teams, &amp;out.Teams
                *out = make([]Team, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespacePoolSpec.
func (in *NamespacePoolSpec) DeepCopy() *NamespacePoolSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespacePoolSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespacePoolStatus) DeepCopyInto(out *NamespacePoolStatus) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespacePoolStatus.
func (in *NamespacePoolStatus) DeepCopy() *NamespacePoolStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespacePoolStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceReservation) DeepCopyInto(out *NamespaceReservation) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceReservation.
func (in *NamespaceReservation) DeepCopy() *NamespaceReservation <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceReservation)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NamespaceReservation) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceReservationList) DeepCopyInto(out *NamespaceReservationList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]NamespaceReservation, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceReservationList.
func (in *NamespaceReservationList) DeepCopy() *NamespaceReservationList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceReservationList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NamespaceReservationList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceReservationSpec) DeepCopyInto(out *NamespaceReservationSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Duration != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Duration, &amp;out.Duration
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceReservationSpec.
func (in *NamespaceReservationSpec) DeepCopy() *NamespaceReservationSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceReservationSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceReservationStatus) DeepCopyInto(out *NamespaceReservationStatus) <span class="cov0" title="0">{
        *out = *in
        in.Expiration.DeepCopyInto(&amp;out.Expiration)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceReservationStatus.
func (in *NamespaceReservationStatus) DeepCopy() *NamespaceReservationStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceReservationStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretsData) DeepCopyInto(out *SecretsData) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretsData.
func (in *SecretsData) DeepCopy() *SecretsData <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecretsData)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Team) DeepCopyInto(out *Team) <span class="cov0" title="0">{
        *out = *in
        if in.Secrets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Secrets, &amp;out.Secrets
                *out = make([]SecretsData, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Team.
func (in *Team) DeepCopy() *Team <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Team)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        clowder "github.com/RedHatInsights/clowder/apis/cloud.redhat.com/v1alpha1"
        "github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers"
        "github.com/RedHatInsights/rhc-osdk-utils/utils"
        "github.com/go-logr/logr"
        "github.com/prometheus/client_golang/prometheus"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// ClowdenvironmentReconciler reconciles a Clowdenvironment object
type ClowdenvironmentReconciler struct {
        client client.Client
        scheme *runtime.Scheme
        log    logr.Logger
}

//+kubebuilder:rbac:groups=cloud.redhat.com,resources=clowdenvironments,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=cloud.redhat.com,resources=clowdenvironments/status,verbs=get

func (r *ClowdenvironmentReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := r.log.WithValues("rid", utils.RandString(5))
        ctx = context.WithValue(ctx, helpers.ErrType("log"), &amp;log)

        env := clowder.ClowdEnvironment{}
        if err := r.client.Get(ctx, req.NamespacedName, &amp;env); err != nil </span><span class="cov0" title="0">{
                if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov0" title="0">r.log.Error(err, "there was an issue retrieving the clowdenvironment", "namespace", env.Name)
                return ctrl.Result{Requeue: true}, err</span>
        }

        <span class="cov8" title="1">log.Info(
                "Reconciling clowdenv",
                "env-name", env.Name,
                "deployments", fmt.Sprintf("%d / %d", env.Status.Deployments.ReadyDeployments, env.Status.Deployments.ManagedDeployments),
        )

        if ready := helpers.VerifyClowdEnvReady(env); !ready </span><span class="cov8" title="1">{
                return ctrl.Result{Requeue: true}, nil
        }</span>

        <span class="cov8" title="1">namespaceName := env.Spec.TargetNamespace
        log.Info("clowdenvironment ready", "namespace", namespaceName)

        if err := helpers.CreateFrontendEnv(ctx, r.client, namespaceName, env); err != nil </span><span class="cov0" title="0">{
                r.log.Error(err, "error encountered with frontend environment", "namespace", namespaceName)
                if aerr := helpers.UpdateAnnotations(ctx, r.client, namespaceName, helpers.AnnotationEnvError.ToMap()); aerr != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{Requeue: true}, fmt.Errorf("error setting annotations: %w", aerr)
                }</span>
        }

        <span class="cov8" title="1">log.Info("namespace ready", "namespace", namespaceName)
        if err := helpers.UpdateAnnotations(ctx, r.client, namespaceName, helpers.AnnotationEnvReady.ToMap()); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{Requeue: true}, fmt.Errorf("error setting annotations: %w", err)
        }</span>

        <span class="cov8" title="1">namespace, err := helpers.GetNamespace(ctx, r.client, namespaceName)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{Requeue: true}, fmt.Errorf("could not retrieve updated namespace %s: %w", namespaceName, err)
        }</span>

        <span class="cov8" title="1">if _, ok := namespace.Annotations[helpers.CompletionTime]; ok </span><span class="cov8" title="1">{
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="1">nsCompletionTime := time.Now()
        var AnnotationCompletionTime = helpers.CustomAnnotation{Annotation: helpers.CompletionTime, Value: nsCompletionTime.String()}

        err = helpers.UpdateAnnotations(ctx, r.client, namespace.Name, AnnotationCompletionTime.ToMap())
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{Requeue: true}, fmt.Errorf("could not retrieve updated namespace [%s] after updating annotations: %w", namespaceName, err)
        }</span>

        <span class="cov8" title="1">if err = r.client.Update(ctx, &amp;namespace); err != nil </span><span class="cov8" title="1">{
                return ctrl.Result{Requeue: true}, err
        }</span>

        <span class="cov0" title="0">elapsed := nsCompletionTime.Sub(namespace.CreationTimestamp.Time)

        averageNamespaceCreationMetrics.With(prometheus.Labels{"pool": namespace.Labels["pool"]}).Observe(float64(elapsed.Seconds()))

        return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *ClowdenvironmentReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        ctx := context.Background()
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;clowder.ClowdEnvironment{}).
                WithEventFilter(poolFilter(ctx, r.client)).
                Complete(r)
}</span>

func poolFilter(ctx context.Context, cl client.Client) predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                UpdateFunc: func(e event.UpdateEvent) bool </span><span class="cov8" title="1">{
                        newObject := e.ObjectNew.(*clowder.ClowdEnvironment)
                        return isOwnedByPool(ctx, cl, newObject.Spec.TargetNamespace)
                }</span>,
                CreateFunc: func(e event.CreateEvent) bool <span class="cov8" title="1">{
                        object := e.Object.(*clowder.ClowdEnvironment)
                        return isOwnedByPool(ctx, cl, object.Spec.TargetNamespace)
                }</span>,
                DeleteFunc: func(_ event.DeleteEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
        }
}

func isOwnedByPool(ctx context.Context, cl client.Client, nsName string) bool <span class="cov8" title="1">{
        ns, err := helpers.GetNamespace(ctx, cl, nsName)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, owner := range ns.GetOwnerReferences() </span><span class="cov8" title="1">{
                if owner.Kind == "NamespacePool" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func isOwnedBySpecificPool(ctx context.Context, cl client.Client, nsName string, uid types.UID) bool <span class="cov8" title="1">{
        ns, err := helpers.GetNamespace(ctx, cl, nsName)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, owner := range ns.GetOwnerReferences() </span><span class="cov8" title="1">{
                if owner.Kind == "NamespacePool" &amp;&amp; owner.UID == uid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package helpers

import (
        "context"
        "fmt"

        clowder "github.com/RedHatInsights/clowder/apis/cloud.redhat.com/v1alpha1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func CreateClowdEnv(ctx context.Context, cl client.Client, spec clowder.ClowdEnvironmentSpec, namespaceName string) error <span class="cov0" title="0">{
        env := clowder.ClowdEnvironment{
                Spec: spec,
        }
        env.SetName(fmt.Sprintf("env-%s", namespaceName))
        env.Spec.TargetNamespace = namespaceName

        ns, err := GetNamespace(ctx, cl, namespaceName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not retrieve namespace [%s] for setting the owner reference on Clowdenvironment [%s]: %w", namespaceName, env.Name, err)
        }</span>

        <span class="cov0" title="0">env.SetOwnerReferences([]metav1.OwnerReference{
                {
                        APIVersion: ns.APIVersion,
                        Kind:       ns.Kind,
                        Name:       ns.Name,
                        UID:        ns.UID,
                },
        })

        if err := cl.Create(ctx, &amp;env); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create clowdenvironment for namespace [%s]: %w", namespaceName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetClowdEnv(ctx context.Context, cl client.Client, namespaceName string) (bool, *clowder.ClowdEnvironment, error) <span class="cov0" title="0">{
        env := clowder.ClowdEnvironment{}
        nn := types.NamespacedName{
                Name:      fmt.Sprintf("env-%s", namespaceName),
                Namespace: namespaceName,
        }

        err := cl.Get(ctx, nn, &amp;env)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("could not retrieve clowdenvironment [%s]: %w", env.Name, err)
        }</span>

        <span class="cov0" title="0">ready := VerifyClowdEnvReady(env)
        if !ready </span><span class="cov0" title="0">{
                return ready, &amp;env, nil
        }</span>

        <span class="cov0" title="0">return ready, &amp;env, nil</span>
}

func VerifyClowdEnvReady(env clowder.ClowdEnvironment) bool <span class="cov0" title="0">{
        // check that hostname is populated if ClowdEnvironment is operating in 'local' web mode
        if env.Spec.Providers.Web.Mode == "local" &amp;&amp; env.Status.Hostname == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">conditions := env.Status.Conditions

        reconciliationSuccessful := false
        deploymentsReady := false

        for i := range conditions </span><span class="cov0" title="0">{
                if conditions[i].Type == "ReconciliationSuccessful" &amp;&amp; conditions[i].Status == "True" </span><span class="cov0" title="0">{
                        reconciliationSuccessful = true
                }</span>
                <span class="cov0" title="0">if conditions[i].Type == "DeploymentsReady" &amp;&amp; conditions[i].Status == "True" </span><span class="cov0" title="0">{
                        deploymentsReady = true
                }</span>
        }

        <span class="cov0" title="0">return (reconciliationSuccessful &amp;&amp; deploymentsReady)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package helpers

import (
        "context"
        "fmt"
        "strings"

        clowder "github.com/RedHatInsights/clowder/apis/cloud.redhat.com/v1alpha1"
        frontend "github.com/RedHatInsights/frontend-operator/api/v1alpha1"
        core "k8s.io/api/core/v1"
        k8serr "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func CreateFrontendEnv(ctx context.Context, cl client.Client, namespaceName string, clowdEnv clowder.ClowdEnvironment) error <span class="cov0" title="0">{
        frontendEnv := frontend.FrontendEnvironment{}
        err := cl.Get(ctx, types.NamespacedName{Name: fmt.Sprintf("env-%s", namespaceName)}, &amp;frontendEnv)
        // Checks if frontenv environment exists
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !k8serr.IsNotFound(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("there was an error when retrieving the frontend environment [env-%s]: %w", namespaceName, err)
        }</span>

        // if frontendEnv not found create it
        <span class="cov0" title="0">splitFqdn := strings.Split(clowdEnv.Status.Hostname, ".")
        host := splitFqdn[0]
        var domain string
        if len(splitFqdn) &gt; 1 </span><span class="cov0" title="0">{
                domain = strings.Join(splitFqdn[1:], ".")
        }</span>

        <span class="cov0" title="0">var ssoURL string
        if domain == "" </span><span class="cov0" title="0">{
                ssoURL = fmt.Sprintf("https://%s-auth/auth/", host)
        }</span> else<span class="cov0" title="0"> {
                ssoURL = fmt.Sprintf("https://%s-auth.%s/auth/", host, domain)
        }</span>

        <span class="cov0" title="0">frontendEnv = frontend.FrontendEnvironment{
                Spec: frontend.FrontendEnvironmentSpec{
                        Hostname:              clowdEnv.Status.Hostname,
                        SSO:                   ssoURL,
                        IngressClass:          clowdEnv.Spec.Providers.Web.IngressClass,
                        GenerateNavJSON:       true,
                        EnableAkamaiCacheBust: false,
                        DefaultReplicas:       func(i int32) *int32 </span><span class="cov0" title="0">{ return &amp;i }</span>(1),
                },
        }

        <span class="cov0" title="0">namespace, err := GetNamespace(ctx, cl, namespaceName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find namespace [%s] for newly created frontendenv: %w", namespaceName, err)
        }</span>

        <span class="cov0" title="0">frontendEnv.SetName(fmt.Sprintf("env-%s", namespace.Name))
        frontendEnv.SetOwnerReferences([]metav1.OwnerReference{
                {
                        APIVersion: namespace.APIVersion,
                        Kind:       namespace.Kind,
                        Name:       namespace.Name,
                        UID:        namespace.UID,
                },
        })

        if err := cl.Create(ctx, &amp;frontendEnv); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating frontend environment [%s]: %w", frontendEnv.Name, err)
        }</span>

        // create "shim" services for keycloak, mbop, mocktitlements
        // this is a temporary solution until apps begin to read the hostnames for these from their cdappconfig.json
        <span class="cov0" title="0">if err := createShimServices(ctx, cl, namespace, clowdEnv); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creation of shim services for keycloak, mbop, and mocktitlements failed for [%s]: %w", clowdEnv.Name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func createShimServices(ctx context.Context, cl client.Client, ns core.Namespace, clowdEnv clowder.ClowdEnvironment) error <span class="cov0" title="0">{
        serviceNames := []string{"keycloak", "mbop", "mocktitlements"}

        for _, serviceName := range serviceNames </span><span class="cov0" title="0">{
                origSvc := core.Service{}
                nn := types.NamespacedName{
                        Name:      fmt.Sprintf("%s-%s", clowdEnv.Name, serviceName),
                        Namespace: ns.Name,
                }

                err := cl.Get(ctx, nn, &amp;origSvc)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // create a new Service with the same configuration spec but a non-prefixed name
                <span class="cov0" title="0">newSvc := core.Service{}
                newSvc.SetName(serviceName)
                newSvc.SetNamespace(ns.Name)
                newSvc.Spec = origSvc.Spec
                // empty the ClusterIPs so a new one is generated
                newSvc.Spec.ClusterIP = ""
                newSvc.Spec.ClusterIPs = []string{}
                newSvc.SetOwnerReferences([]metav1.OwnerReference{
                        {
                                APIVersion: ns.APIVersion,
                                Kind:       ns.Kind,
                                Name:       ns.Name,
                                UID:        ns.UID,
                        },
                })

                err = cl.Create(ctx, &amp;newSvc)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create shim service for [%s]: %w", serviceName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package helpers

import (
        "context"
        "fmt"
        "strings"

        core "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/util/retry"

        crd "github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1"
        "github.com/RedHatInsights/rhc-osdk-utils/utils"
        projectv1 "github.com/openshift/api/project/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func CreateNamespace(ctx context.Context, cl client.Client, pool *crd.NamespacePool) (string, error) <span class="cov0" title="0">{
        ns := core.Namespace{}

        ns.Name = fmt.Sprintf("ephemeral-%s", strings.ToLower(utils.RandString(6)))

        if pool.Spec.Local </span><span class="cov0" title="0">{
                if err := cl.Create(ctx, &amp;ns); err != nil </span><span class="cov0" title="0">{
                        return ns.Name, fmt.Errorf("could not create namespace [%s]: %w", ns.Name, err)
                }</span>
        } else<span class="cov0" title="0"> {
                project := projectv1.ProjectRequest{}
                project.Name = ns.Name
                if err := cl.Create(ctx, &amp;project); err != nil </span><span class="cov0" title="0">{
                        return ns.Name, fmt.Errorf("could not create project [%s]: %w", project.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return ns.Name, nil</span>
}

func UpdateNamespaceResources(ctx context.Context, cl client.Client, pool *crd.NamespacePool, nsName string) (core.Namespace, error) <span class="cov0" title="0">{
        ns, err := GetNamespace(ctx, cl, nsName)
        if err != nil </span><span class="cov0" title="0">{
                return ns, fmt.Errorf("could not retrieve namespace [%s]: %w", nsName, err)
        }</span>

        <span class="cov0" title="0">utils.UpdateAnnotations(&amp;ns, CreateInitialAnnotations())
        utils.UpdateLabels(&amp;ns, CreateInitialLabels(pool.Name))
        ns.SetOwnerReferences([]metav1.OwnerReference{pool.MakeOwnerReference()})

        if err := cl.Update(ctx, &amp;ns); err != nil </span><span class="cov0" title="0">{
                return ns, fmt.Errorf("could not update Project [%s]: %w", nsName, err)
        }</span>

        // Create ClowdEnvironment
        <span class="cov0" title="0">if err := CreateClowdEnv(ctx, cl, pool.Spec.ClowdEnvironment, nsName); err != nil </span><span class="cov0" title="0">{
                return ns, fmt.Errorf("error creating ClowdEnvironment for namespace [%s]: %w", nsName, err)
        }</span>

        // Create LimitRange
        <span class="cov0" title="0">limitRange := pool.Spec.LimitRange
        limitRange.SetNamespace(nsName)

        if err := cl.Create(ctx, &amp;limitRange); err != nil </span><span class="cov0" title="0">{
                return ns, fmt.Errorf("error creating LimitRange for namespace [%s]: %w", nsName, err)
        }</span>

        // Create ResourceQuotas
        <span class="cov0" title="0">resourceQuotas := pool.Spec.ResourceQuotas
        for _, quota := range resourceQuotas.Items </span><span class="cov0" title="0">{
                innerQuota := quota
                innerQuota.SetNamespace(nsName)
                if err := cl.Create(ctx, &amp;innerQuota); err != nil </span><span class="cov0" title="0">{
                        return ns, fmt.Errorf("error creating ResourceQuota for namespace [%s]: %w", nsName, err)
                }</span>
        }

        // Copy secrets
        <span class="cov0" title="0">if err := CopySecrets(ctx, cl, nsName); err != nil </span><span class="cov0" title="0">{
                return ns, fmt.Errorf("error copying secrets from ephemeral-base namespace to namespace [%s]: %w", nsName, err)
        }</span>

        <span class="cov0" title="0">return ns, nil</span>
}

func GetNamespace(ctx context.Context, cl client.Client, namespaceName string) (core.Namespace, error) <span class="cov0" title="0">{
        namespace := core.Namespace{}

        // Use retry in case object retrieval is attempted before creation is done
        err := retry.OnError(
                wait.Backoff(retry.DefaultBackoff),
                func(error) bool </span><span class="cov0" title="0">{ return true }</span>,
                func() error <span class="cov0" title="0">{
                        err := cl.Get(ctx, types.NamespacedName{Name: namespaceName}, &amp;namespace)
                        return err
                }</span>,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return core.Namespace{}, err
        }</span>

        <span class="cov0" title="0">return namespace, nil</span>
}

func GetReadyNamespaces(ctx context.Context, cl client.Client, poolName string) ([]core.Namespace, error) <span class="cov0" title="0">{
        namespaceList := core.NamespaceList{}

        var LabelPoolType = CustomLabel{Label: LabelPool, Value: poolName}
        validatedSelector, _ := labels.ValidatedSelectorFromSet(LabelPoolType.ToMap())

        namespaceListOptions := &amp;client.ListOptions{LabelSelector: validatedSelector}

        if err := cl.List(ctx, &amp;namespaceList, namespaceListOptions); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error listing namespaces for pool [%s]: %w", poolName, err)
        }</span>

        <span class="cov0" title="0">var ready []core.Namespace

        for _, namespace := range namespaceList.Items </span><span class="cov0" title="0">{
                for _, owner := range namespace.GetOwnerReferences() </span><span class="cov0" title="0">{
                        if owner.Kind == KindNamespacePool </span><span class="cov0" title="0">{
                                ready = CheckReadyStatus(poolName, namespace, ready)
                        }</span>
                }
        }

        <span class="cov0" title="0">return ready, nil</span>
}

func CheckReadyStatus(pool string, namespace core.Namespace, ready []core.Namespace) []core.Namespace <span class="cov0" title="0">{
        if val := namespace.ObjectMeta.Labels[LabelPool]; val == pool </span><span class="cov0" title="0">{
                if val, ok := namespace.ObjectMeta.Annotations[AnnotationEnvStatus]; ok &amp;&amp; val == EnvStatusReady </span><span class="cov0" title="0">{
                        ready = append(ready, namespace)
                }</span>
        }

        <span class="cov0" title="0">return ready</span>
}

func UpdateAnnotations(ctx context.Context, cl client.Client, namespaceName string, annotations map[string]string) error <span class="cov0" title="0">{
        namespace, err := GetNamespace(ctx, cl, namespaceName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error updating annotations for namespace [%s]: %w", namespaceName, err)
        }</span>

        <span class="cov0" title="0">utils.UpdateAnnotations(&amp;namespace, annotations)

        err = retry.RetryOnConflict(
                retry.DefaultBackoff,
                func() error </span><span class="cov0" title="0">{
                        if err = cl.Update(ctx, &amp;namespace); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("there was an issue updating annotations for namespace [%s]: %w", namespaceName, err)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
        )

        <span class="cov0" title="0">return nil</span>
}

func CopySecrets(ctx context.Context, cl client.Client, namespaceName string) error <span class="cov0" title="0">{
        secrets := core.SecretList{}
        if err := cl.List(ctx, &amp;secrets, client.InNamespace(NamespaceEphemeralBase)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not list secrets in [%s]: %w", NamespaceEphemeralBase, err)
        }</span>

        <span class="cov0" title="0">for _, secret := range secrets.Items </span><span class="cov0" title="0">{
                // Filter which secrets should be copied
                // All secrets with the "qontract" annotations are defined in app-interface
                if val, ok := secret.Annotations[QontractIntegrationSecret]; !ok </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> if val != OpenShiftVaultSecretsSecret </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if val, ok := secret.Annotations[BonfireGinoreSecret]; ok </span><span class="cov0" title="0">{
                        if val == "true" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">sourceNamespaceName := types.NamespacedName{
                        Name:      secret.Name,
                        Namespace: secret.Namespace,
                }

                destinationNamespace := types.NamespacedName{
                        Name:      secret.Name,
                        Namespace: namespaceName,
                }

                newNamespaceSecret, err := utils.CopySecret(ctx, cl, sourceNamespaceName, destinationNamespace)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not copy secrets into newly created namespace [%s]: %w", namespaceName, err)
                }</span>

                <span class="cov0" title="0">if err := cl.Create(ctx, newNamespaceSecret); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not create new secret for namespace [%s]: %w", namespaceName, err)
                }</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func DeleteNamespace(ctx context.Context, cl client.Client, namespaceName string) error <span class="cov0" title="0">{
        if err := UpdateAnnotations(ctx, cl, namespaceName, AnnotationEnvDeleting.ToMap()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error updating annotations for [%s]: %w", namespaceName, err)
        }</span>

        <span class="cov0" title="0">namespace, err := GetNamespace(ctx, cl, namespaceName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not retrieve namespace [%s] to be deleted: %w", namespaceName, err)
        }</span>

        <span class="cov0" title="0">if err := cl.Delete(ctx, &amp;namespace); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not delete namespace [%s]: %w", namespaceName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package helpers

func IsPoolAtLimit(currentSize int, sizeLimit int) bool <span class="cov0" title="0">{
        return currentSize == sizeLimit
}</span>

func CalculateNamespaceQuantityDelta(poolSizeLimit *int, size int, namespacesReady int, namespacesCreating int, namespacesReserved int) int <span class="cov0" title="0">{
        currentNamespaceQuantity := namespacesReady + namespacesCreating + namespacesReserved
        currentNamespaceQueue := namespacesReady + namespacesCreating

        if poolSizeLimit == nil </span><span class="cov0" title="0">{
                return size - currentNamespaceQueue
        }</span>

        <span class="cov0" title="0">sizeLimit := *poolSizeLimit

        if sizeLimit-currentNamespaceQuantity &lt; size-currentNamespaceQueue </span><span class="cov0" title="0">{
                return sizeLimit - currentNamespaceQuantity
        }</span>

        <span class="cov0" title="0">return size - currentNamespaceQueue</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package helpers

import (
        "context"
        "fmt"

        crd "github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1"
        "github.com/RedHatInsights/rhc-osdk-utils/utils"
        "github.com/go-logr/logr"
        core "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// This function handles copying AI secrets
func CopyReservationSecrets(ctx context.Context, cl client.Client, namespaceName string, res *crd.NamespaceReservation, log logr.Logger) error <span class="cov0" title="0">{
        secrets := core.SecretList{}

        nsPoolObject := crd.NamespacePool{}

        err := cl.Get(ctx, types.NamespacedName{Name: "ai-development", Namespace: NamespaceHcmAi}, &amp;nsPoolObject)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("could not retrieve namespacepool [%s]", PoolAiDevelopment))
        }</span>
        <span class="cov0" title="0">log.Info(fmt.Sprintf("[%s]: %v", PoolAiDevelopment, nsPoolObject))

        err = cl.List(ctx, &amp;secrets, client.InNamespace(NamespaceHcmAi))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not list secrets in [%s]: %w", NamespaceHcmAi, err)
        }</span>

        <span class="cov0" title="0">teamName := res.Spec.Team
        allTeams := nsPoolObject.Spec.Teams

        // Find the team configuration
        team := findTeamByName(allTeams, teamName)
        if team == nil </span><span class="cov0" title="0">{
                log.Info(fmt.Sprintf("Team [%s] not found in namespace pool configuration", teamName))
                return nil
        }</span>

        // Copy secrets for the team
        <span class="cov0" title="0">return copyTeamSecrets(ctx, cl, secrets.Items, team.Secrets, namespaceName, log)</span>
}

// findTeamByName searches for a team by name in the teams slice
func findTeamByName(teams []crd.Team, teamName string) *crd.Team <span class="cov0" title="0">{
        for _, team := range teams </span><span class="cov0" title="0">{
                if team.Name == teamName </span><span class="cov0" title="0">{
                        return &amp;team
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// copyTeamSecrets copies all secrets configured for a team to the target namespace
func copyTeamSecrets(ctx context.Context, cl client.Client, availableSecrets []core.Secret, teamSecrets []crd.SecretsData, targetNamespace string, log logr.Logger) error <span class="cov0" title="0">{
        for _, teamSecret := range teamSecrets </span><span class="cov0" title="0">{
                secret := findSecretByName(availableSecrets, teamSecret.Name)
                if secret == nil </span><span class="cov0" title="0">{
                        log.Info(fmt.Sprintf("Secret [%s] not found in source namespace", teamSecret.Name))
                        continue</span>
                }

                <span class="cov0" title="0">if err := copySecretToNamespace(ctx, cl, secret, teamSecret, targetNamespace); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy secret [%s] to namespace [%s]: %w", teamSecret.Name, targetNamespace, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// findSecretByName searches for a secret by name in the secrets slice
func findSecretByName(secrets []core.Secret, secretName string) *core.Secret <span class="cov0" title="0">{
        for _, secret := range secrets </span><span class="cov0" title="0">{
                if secret.Name == secretName </span><span class="cov0" title="0">{
                        return &amp;secret
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// copySecretToNamespace copies a single secret to the target namespace with proper naming
func copySecretToNamespace(ctx context.Context, cl client.Client, secret *core.Secret, teamSecret crd.SecretsData, targetNamespace string) error <span class="cov0" title="0">{
        sourceNamespaceName := types.NamespacedName{
                Name:      secret.Name,
                Namespace: secret.Namespace,
        }

        // Determine the destination secret name
        destinationSecretName := teamSecret.Name
        if teamSecret.DestName != "" </span><span class="cov0" title="0">{
                destinationSecretName = teamSecret.DestName
        }</span>

        <span class="cov0" title="0">destinationNamespaceName := types.NamespacedName{
                Name:      destinationSecretName,
                Namespace: targetNamespace,
        }

        newNamespaceSecret, err := utils.CopySecret(ctx, cl, sourceNamespaceName, destinationNamespaceName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not copy secret: %w", err)
        }</span>

        <span class="cov0" title="0">if err := cl.Create(ctx, newNamespaceSecret); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NewReservation creates a mock reservation for testing
func NewReservation(resName string, duration string, requester string, team string, pool string) *crd.NamespaceReservation <span class="cov0" title="0">{
        return &amp;crd.NamespaceReservation{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "cloud.redhat.com/",
                        Kind:       "NamespaceReservation",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: resName,
                },
                Spec: crd.NamespaceReservationSpec{
                        Duration:  utils.StringPtr(duration),
                        Requester: requester,
                        Team:      team,
                        Pool:      pool,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package helpers

type CustomAnnotation struct {
        Annotation string
        Value      string
}

type CustomLabel struct {
        Label string
        Value string
}

func CreateInitialAnnotations() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                AnnotationEnvStatus: EnvStatusCreating,
                AnnotationReserved:  FalseValue,
        }
}</span>

func CreateInitialLabels(poolName string) map[string]string <span class="cov0" title="0">{
        return map[string]string{
                LabelOperatorNS: TrueValue,
                LabelPool:       poolName,
        }
}</span>

func (a *CustomAnnotation) ToMap() map[string]string <span class="cov0" title="0">{
        return map[string]string{a.Annotation: a.Value}
}</span>

func (l *CustomLabel) ToMap() map[string]string <span class="cov0" title="0">{
        return map[string]string{l.Label: l.Value}
}</span>

var AnnotationEnvReady = CustomAnnotation{Annotation: AnnotationEnvStatus, Value: EnvStatusReady}
var AnnotationEnvCreating = CustomAnnotation{Annotation: AnnotationEnvStatus, Value: EnvStatusCreating}
var AnnotationEnvError = CustomAnnotation{Annotation: AnnotationEnvStatus, Value: EnvStatusError}
var AnnotationEnvDeleting = CustomAnnotation{Annotation: AnnotationEnvStatus, Value: EnvStatusDeleting}

var AnnotationReservedTrue = CustomAnnotation{Annotation: AnnotationReserved, Value: TrueValue}
var AnnotationReservedFalse = CustomAnnotation{Annotation: AnnotationReserved, Value: FalseValue}

var LabelOperatorNamespaceTrue = CustomLabel{Label: LabelOperatorNS, Value: TrueValue}

type ErrType string
</pre>
		
		<pre class="file" id="file10" style="display: none">package controllers

import (
        "github.com/prometheus/client_golang/prometheus"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var userNamespaceReservationCount = map[string]int{}

var (
        totalSuccessfulPoolReservationsCountMetrics = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "successful_pool_reservations_total",
                        Help: "Total successful reservations from each pool",
                },
                []string{"pool"},
        )

        totalFailedPoolReservationsCountMetrics = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "failed_pool_reservations_total",
                        Help: "Total failed reservations from each pool",
                },
                []string{"pool"},
        )

        averageRequestedDurationMetrics = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name: "namespace_reservation_duration_average",
                        Help: "Average duration for namespace reservations (In hours)",
                        // Inf+ bucket is made implicitly by the prometheus library
                        Buckets: []float64{1, 2, 4, 8, 24, 48, 168, 336},
                },
                []string{"controller", "pool"},
        )

        averageNamespaceCreationMetrics = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "namespace_creation_average_seconds",
                        Help:    "Average time namespace creation occurs'",
                        Buckets: []float64{1, 2, 3, 4, 5, 7, 14, 28, 56, 112, 224},
                },
                []string{"pool"},
        )

        averageReservationToDeploymentMetrics = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "average_time_reservation_to_deployment_seconds",
                        Help:    "Average time it takes from reservation to deployment in milliseconds",
                        Buckets: []float64{1, 2, 3, 4, 5, 7, 14, 28, 56, 112, 224},
                },
                []string{"controller", "pool"},
        )

        activeReservationTotalMetrics = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "active_reservation_total",
                        Help: "Total active reservations",
                },
                []string{"controller"},
        )

        resQuantityByUserMetrics = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "res_quantity_by_user_count",
                        Help: "Quantity of reservations by user",
                },
                []string{"user"},
        )

        enoVersion = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "eno_version",
                        Help: "ENOVersion 1 if present, 0 if not",
                },
                []string{"version"},
        )
)

func init() <span class="cov8" title="1">{
        metrics.Registry.MustRegister(
                totalSuccessfulPoolReservationsCountMetrics,
                totalFailedPoolReservationsCountMetrics,
                averageRequestedDurationMetrics,
                averageNamespaceCreationMetrics,
                averageReservationToDeploymentMetrics,
                activeReservationTotalMetrics,
                resQuantityByUserMetrics,
                enoVersion,
        )
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2021.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        core "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        crd "github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1"
        "github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers"
        "github.com/RedHatInsights/rhc-osdk-utils/utils"
)

// NamespacePoolReconciler reconciles a NamespacePool object
type NamespacePoolReconciler struct {
        client client.Client
        scheme *runtime.Scheme
        log    logr.Logger
}

//+kubebuilder:rbac:groups=cloud.redhat.com,resources=namespacepools,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=cloud.redhat.com,resources=namespacepools/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=cloud.redhat.com,resources=namespacepools/finalizers,verbs=update

func (r *NamespacePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := r.log.WithValues("rid", utils.RandString(5))
        ctx = context.WithValue(ctx, helpers.ErrType("log"), &amp;log)

        pool := crd.NamespacePool{}

        if err := r.client.Get(ctx, req.NamespacedName, &amp;pool); err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("cannot retrieve [%s] pool resource", pool.Name))
                return ctrl.Result{Requeue: true}, err
        }</span>

        <span class="cov8" title="1">errNamespaceList, err := r.getPoolStatus(ctx, &amp;pool)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "unable to get status of owned namespaces")
                return ctrl.Result{Requeue: true}, err
        }</span>

        <span class="cov8" title="1">if len(errNamespaceList) &gt; 0 </span><span class="cov8" title="1">{
                log.Info(fmt.Sprintf("[%d] namespaces in error state are queued for deletion", len(errNamespaceList)))
                err = r.deleteErrorNamespaces(ctx, errNamespaceList)
                if err != nil </span><span class="cov8" title="1">{
                        r.log.Error(err, "Unable to delete namespaces in error state")
                        return ctrl.Result{Requeue: true}, err
                }</span>
        }

        <span class="cov8" title="1">log.Info(fmt.Sprintf("[%s] pool status", pool.Name),
                "ready", pool.Status.Ready,
                "creating", pool.Status.Creating,
                "reserved", pool.Status.Reserved)

        quantityOfNamespaces := r.getNamespaceQuantityDelta(pool)

        if quantityOfNamespaces &gt; 0 </span><span class="cov8" title="1">{
                log.Info(fmt.Sprintf("filling [%s] pool with [%d] namespace(s)", pool.Name, quantityOfNamespaces))
                err := r.increaseReadyNamespacesQueue(ctx, pool, quantityOfNamespaces)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("unable to create more namespaces for [%s] pool.", pool.Name))
                        return ctrl.Result{Requeue: true}, err
                }</span>
        } else<span class="cov8" title="1"> if quantityOfNamespaces &lt; 0 </span><span class="cov8" title="1">{
                log.Info(fmt.Sprintf("excess number of ready namespaces in [%s] pool detected, removing [%d] namespace(s)", pool.Name, (quantityOfNamespaces * -1)))
                err := r.decreaseReadyNamespacesQueue(ctx, pool.Name, quantityOfNamespaces)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Error(err, fmt.Sprintf("unable to delete excess namespaces for [%s] pool.", pool.Name))
                        return ctrl.Result{Requeue: true}, err
                }</span>
        }

        <span class="cov8" title="1">if err := r.client.Status().Update(ctx, &amp;pool); err != nil </span><span class="cov8" title="1">{
                log.Error(err, fmt.Sprintf("cannot update [%s] pool status", pool.Name))
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *NamespacePoolReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;crd.NamespacePool{}).
                Watches(&amp;core.Namespace{},
                        handler.EnqueueRequestsFromMapFunc(r.EnqueueNamespace),
                ).
                Complete(r)
}</span>

func (r *NamespacePoolReconciler) EnqueueNamespace(_ context.Context, a client.Object) []reconcile.Request <span class="cov8" title="1">{
        labels := a.GetLabels()

        if pool, ok := labels["pool"]; ok </span><span class="cov8" title="1">{
                return []reconcile.Request{{
                        NamespacedName: types.NamespacedName{
                                Name: pool,
                        },
                }}
        }</span>
        <span class="cov8" title="1">return []reconcile.Request{}</span>

}

func (r *NamespacePoolReconciler) deleteErrorNamespaces(ctx context.Context, errNamespaceList []string) error <span class="cov8" title="1">{
        for _, nsName := range errNamespaceList </span><span class="cov8" title="1">{
                r.log.Info("deleting namespace", "namespace", nsName)
                err := helpers.DeleteNamespace(ctx, r.client, nsName)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("could not delete namespace in error state: [%w]", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *NamespacePoolReconciler) getPoolStatus(ctx context.Context, pool *crd.NamespacePool) ([]string, error) <span class="cov8" title="1">{
        var readyNamespaceCount int
        var creatingNamespaceCount int
        var reservedNamespaceCount int

        nsList := core.NamespaceList{}
        errNamespaceList := []string{}

        labelSelector, _ := labels.Parse(fmt.Sprintf("pool=%s", pool.Name))
        nsListOptions := &amp;client.ListOptions{LabelSelector: labelSelector}
        if err := r.client.List(ctx, &amp;nsList, nsListOptions); err != nil </span><span class="cov0" title="0">{
                r.log.Error(err, "unable to retrieve list of existing ready namespaces")
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, ns := range nsList.Items </span><span class="cov8" title="1">{
                for _, owner := range ns.GetOwnerReferences() </span><span class="cov8" title="1">{
                        if owner.UID == pool.GetUID() </span><span class="cov8" title="1">{
                                switch ns.Annotations[helpers.AnnotationEnvStatus] </span>{
                                case helpers.EnvStatusReady:<span class="cov8" title="1">
                                        readyNamespaceCount++</span>
                                case helpers.EnvStatusCreating:<span class="cov8" title="1">
                                        creatingNamespaceCount++</span>
                                case helpers.EnvStatusError:<span class="cov8" title="1">
                                        r.log.Info("prepping for deletion due to error status", "namespace", ns.Name)
                                        errNamespaceList = append(errNamespaceList, ns.Name)</span>
                                }
                        } else<span class="cov8" title="1"> if owner.Kind == "NamespaceReservation" </span><span class="cov8" title="1">{
                                reservedNamespaceCount++
                        }</span>
                }
        }

        <span class="cov8" title="1">pool.Status.Ready = readyNamespaceCount
        pool.Status.Creating = creatingNamespaceCount
        pool.Status.Reserved = reservedNamespaceCount

        return errNamespaceList, nil</span>
}

func (r *NamespacePoolReconciler) getNamespaceQuantityDelta(pool crd.NamespacePool) int <span class="cov8" title="1">{
        poolSizeLimit := pool.Spec.SizeLimit
        size := pool.Spec.Size
        namespacesReady := pool.Status.Ready
        namespacesCreating := pool.Status.Creating
        namespacesReserved := pool.Status.Reserved
        namespacePoolTotal := namespacesReady + namespacesCreating + namespacesReserved

        namespaceDelta := helpers.CalculateNamespaceQuantityDelta(poolSizeLimit, size, namespacesReady, namespacesCreating, namespacesReserved)

        isAtLimit := false
        if poolSizeLimit != nil </span><span class="cov8" title="1">{
                isAtLimit = helpers.IsPoolAtLimit(namespacePoolTotal, *poolSizeLimit)
        }</span>

        <span class="cov8" title="1">if namespaceDelta == 0 &amp;&amp; isAtLimit </span><span class="cov8" title="1">{
                r.log.Info(fmt.Sprintf("max number of namespaces for pool [%s] already created", pool.Name), "max namespaces", poolSizeLimit)
        }</span>

        <span class="cov8" title="1">return namespaceDelta</span>
}

func (r *NamespacePoolReconciler) increaseReadyNamespacesQueue(ctx context.Context, pool crd.NamespacePool, increaseSize int) error <span class="cov8" title="1">{
        for i := 0; i &lt; increaseSize; i++ </span><span class="cov8" title="1">{
                nsName, err := helpers.CreateNamespace(ctx, r.client, &amp;pool)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Error(err, "namespace/project creation failed for [%s]", nsName)
                }</span>

                <span class="cov8" title="1">ns, err := helpers.UpdateNamespaceResources(ctx, r.client, &amp;pool, nsName)
                if err == nil </span><span class="cov8" title="1">{
                        r.log.Info(fmt.Sprintf("successfully created namespace [%s] in [%s] pool", nsName, pool.Name))
                        continue</span>
                }

                <span class="cov0" title="0">r.log.Error(err, fmt.Sprintf("error while updating namespace resources for [%s]", nsName))
                if err := r.client.Delete(ctx, &amp;ns); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot delete error namespace [%s]", nsName)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *NamespacePoolReconciler) decreaseReadyNamespacesQueue(ctx context.Context, poolName string, decreaseSize int) error <span class="cov8" title="1">{
        namespaceList, err := helpers.GetReadyNamespaces(ctx, r.client, poolName)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err, fmt.Sprintf("unable to retrieve list of namespaces from [%s] pool", poolName))
                return err
        }</span>

        <span class="cov8" title="1">if len(namespaceList) == 0 </span><span class="cov0" title="0">{
                r.log.Info(fmt.Sprintf("no ready namespaces to delete for [%s] pool", poolName))
        }</span>

        <span class="cov8" title="1">for i := decreaseSize; i &lt; 0; i++ </span><span class="cov8" title="1">{
                for _, namespace := range namespaceList </span><span class="cov8" title="1">{
                        if namespace.Annotations[helpers.AnnotationEnvStatus] == helpers.EnvStatusReady &amp;&amp; namespace.Annotations[helpers.AnnotationReserved] == "false" </span><span class="cov8" title="1">{
                                err := helpers.UpdateAnnotations(ctx, r.client, namespace.Name, helpers.AnnotationEnvError.ToMap())
                                if err != nil </span><span class="cov0" title="0">{
                                        r.log.Error(err, "error while updating annotations on namespace", "namespace", namespace.Name)
                                        return err
                                }</span>

                                <span class="cov8" title="1">r.log.Info(fmt.Sprintf("successfully deleted excess namespace [%s] from [%s] pool", namespace.Name, poolName))
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "fmt"
        "time"

        crd "github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1"
        helpers "github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com/helpers"
        "github.com/RedHatInsights/rhc-osdk-utils/utils"
        "github.com/go-logr/logr"
        core "k8s.io/api/core/v1"
        rbac "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/util/workqueue"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        "github.com/prometheus/client_golang/prometheus"
        k8serr "k8s.io/apimachinery/pkg/api/errors"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/controller"
)

// NamespaceReservationReconciler reconciles a NamespaceReservation object
type NamespaceReservationReconciler struct {
        client client.Client
        scheme *runtime.Scheme
        poller *Poller
        log    logr.Logger
}

//+kubebuilder:rbac:groups=cloud.redhat.com,resources=namespacereservations,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=cloud.redhat.com,resources=namespacereservations/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=cloud.redhat.com,resources=namespacereservations/finalizers,verbs=update
//+kubebuilder:rbac:groups=cloud.redhat.com,resources=clowdenvironments,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=cloud.redhat.com,resources=frontendenvironments,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="",resources=secrets;events;namespaces;limitranges;resourcequotas,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="operators.coreos.com",resources=operators,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="project.openshift.io",resources=projects;projectrequests,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="config.openshift.io",resources=ingresses,verbs=get;list;watch
//+kubebuilder:rbac:groups=rbac.authorization.k8s.io,resources=rolebindings;roles,verbs=get;list;watch;create;update;patch;delete

func (r *NamespaceReservationReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := r.log.WithValues("rid", utils.RandString(5))
        ctx = context.WithValue(ctx, helpers.ErrType("log"), &amp;log)

        // Fetch the reservation
        res := crd.NamespaceReservation{}
        if err := r.client.Get(ctx, req.NamespacedName, &amp;res); err != nil </span><span class="cov8" title="1">{
                if k8serr.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Must have been deleted
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov0" title="0">r.log.Error(err, fmt.Sprintf("there was an issue retrieving the reservation object for namespace [%s]", req.NamespacedName.Namespace))
                return ctrl.Result{Requeue: true}, err</span>
        }

        <span class="cov8" title="1">if res.Status.Pool == "" </span><span class="cov8" title="1">{
                if res.Spec.Pool == "" </span><span class="cov0" title="0">{
                        res.Status.Pool = "default"
                }</span> else<span class="cov8" title="1"> {
                        res.Status.Pool = res.Spec.Pool
                }</span>
        }

        <span class="cov8" title="1">switch res.Status.State </span>{
        case "active":<span class="cov8" title="1">
                log.Info("Reconciling active reservation", "name", res.Name, "namespace", res.Status.Namespace)
                expirationTS, err := getExpirationTime(&amp;res)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Error(err, "Could not get expiration time for reservation", "name", res.Name)
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">res.Status.Expiration = expirationTS
                r.poller.activeReservations[res.Name] = expirationTS

                if err := r.client.Status().Update(ctx, &amp;res); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Cannot update reservation status", "name", res.Name)
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">activeReservationTotalMetrics.With(prometheus.Labels{"controller": "namespacereservation"}).Set(float64(len(r.poller.activeReservations)))

                return ctrl.Result{}, nil</span>

        case "waiting":<span class="cov8" title="1">
                log.Info("Reconciling waiting reservation", "name", res.Name)
                expirationTS, err := getExpirationTime(&amp;res)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Could not get expiration time for reservation", "name", res.Name)
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">if r.poller.namespaceIsExpired(expirationTS) </span><span class="cov8" title="1">{
                        if err := r.client.Delete(ctx, &amp;res); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "Unable to delete waiting reservation", "res-name", res.Name)
                        }</span>
                        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
                }
                <span class="cov8" title="1">fallthrough</span> // fallthrough to default case to check for ns availability if not expired

        default:<span class="cov8" title="1">
                // if no, requeue and wait for pool to populate
                log.Info("Reconciling reservation", "name", res.Name)
                log.Info(fmt.Sprintf("Checking %s pool for ready namespaces", res.Status.Pool), "name", res.Name)

                expirationTS, err := getExpirationTime(&amp;res)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Could not set expiration time on reservation. Deleting", "res-name", res.Name)
                        if err := r.client.Delete(ctx, &amp;res); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "cannot delete resource - aborting delete", "name", res.Name)
                        }</span>
                        <span class="cov0" title="0">return ctrl.Result{}, err</span>
                }

                <span class="cov8" title="1">nsList, err := helpers.GetReadyNamespaces(ctx, r.client, res.Status.Pool)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("unable to retrieve list of namespaces from '%s' pool", res.Status.Pool), "res-name", res.Name)
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if len(nsList) &lt; 1 </span><span class="cov8" title="1">{
                        log.Info(fmt.Sprintf("requeue to wait for namespace population from '%s' pool", res.Status.Pool), "name", res.Name)
                        if res.Status.State == "" </span><span class="cov8" title="1">{
                                res.Status.State = "waiting"
                                res.Status.Expiration = expirationTS
                                err := r.client.Status().Update(ctx, &amp;res)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(err, "cannot update status", "name", res.Name)
                                        return ctrl.Result{}, err
                                }</span>
                        }
                        <span class="cov8" title="1">return ctrl.Result{Requeue: true}, nil</span>
                }

                // Check to see if there's an error with the Get
                <span class="cov8" title="1">readyNsName := nsList[0].Name
                log.Info(fmt.Sprintf("Found namespace in '%s' pool; verifying ready status", res.Status.Pool))

                // Verify that the ClowdEnv has been set up for the requested namespace
                if err := r.verifyClowdEnvForReadyNs(ctx, readyNsName); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, err.Error(), "namespace", readyNsName)
                        if err := helpers.UpdateAnnotations(ctx, r.client, readyNsName, helpers.AnnotationEnvError.ToMap()); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, fmt.Sprintf("unable to update annotations for unready namespace in '%s' pool", res.Status.Pool), "namespace", readyNsName)
                                return ctrl.Result{Requeue: true}, err
                        }</span>
                        <span class="cov0" title="0">return ctrl.Result{Requeue: true}, err</span>
                }

                // Resolve the requested namespace and remove it from the pool
                <span class="cov8" title="1">if err := r.reserveNamespace(ctx, readyNsName, &amp;res); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("could not reserve namespace from '%s' pool", res.Status.Pool), "namespace", readyNsName)

                        totalFailedPoolReservationsCountMetrics.With(prometheus.Labels{"pool": res.Spec.Pool}).Inc()

                        return ctrl.Result{Requeue: true}, err
                }</span>

                // Update reservation status fields
                <span class="cov8" title="1">res.Status.Namespace = readyNsName
                res.Status.Expiration = expirationTS
                res.Status.State = "active"

                r.poller.activeReservations[res.Name] = expirationTS

                log.Info("updating NamespaceReservation status")
                log.Info("reservation details",
                        "res-name", res.Name,
                        "res-uuid", res.ObjectMeta.UID,
                        "created", res.ObjectMeta.CreationTimestamp,
                        "spec", res.Spec,
                        "status", res.Status,
                )
                if err := r.client.Status().Update(ctx, &amp;res); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "cannot update status")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">duration, err := parseDurationTime(*res.Spec.Duration)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "cannot parse duration")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if _, ok := userNamespaceReservationCount[res.Spec.Requester]; !ok </span><span class="cov8" title="1">{
                        userNamespaceReservationCount[res.Spec.Requester] = 0
                }</span>

                <span class="cov8" title="1">userNamespaceReservationCount[res.Spec.Requester]++

                resQuantityByUserMetrics.With(prometheus.Labels{"user": res.Spec.Requester}).Set(float64(userNamespaceReservationCount[res.Spec.Requester]))

                averageRequestedDurationMetrics.With(prometheus.Labels{"controller": "namespacereservation", "pool": res.Spec.Pool}).Observe(float64(duration.Hours()))

                elapsed := time.Since(res.CreationTimestamp.Time)

                averageReservationToDeploymentMetrics.With(prometheus.Labels{"controller": "namespacereservation", "pool": res.Spec.Pool}).Observe(float64(elapsed.Seconds()))

                return ctrl.Result{}, nil</span>
        }
}

// SetupWithManager sets up the controller with the Manager.
func (r *NamespaceReservationReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;crd.NamespaceReservation{}).
                WithOptions(controller.Options{
                        RateLimiter: workqueue.NewTypedItemExponentialFailureRateLimiter[reconcile.Request](time.Duration(500*time.Millisecond), time.Duration(60*time.Second)),
                }).
                Complete(r)
}</span>

func (r *NamespaceReservationReconciler) reserveNamespace(ctx context.Context, readyNsName string, res *crd.NamespaceReservation) error <span class="cov8" title="1">{
        nsObject := core.Namespace{}
        err := r.client.Get(ctx, types.NamespacedName{Name: readyNsName}, &amp;nsObject)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err, fmt.Sprintf("could not retrieve namespace from '%s' pool", res.Status.Pool), "name", readyNsName)
                return err
        }</span>

        // Set Owner Reference on the ns we just reserved to ensure
        // the namespace is deleted when the reservation is deleted
        <span class="cov8" title="1">nsObject.SetOwnerReferences([]metav1.OwnerReference{res.MakeOwnerReference()})

        // Set namespace reserved
        // TODO: update bonfire to only ready "status" annotation
        nsObject.Annotations["reserved"] = "true"

        teamName := res.Spec.Team

        // Specific pool(s) asks the user for a team name
        if teamName != "" </span><span class="cov8" title="1">{
                r.log.Info("team name [%s] has been set on namespacereservation; copying required secrets into namespace [%s]", teamName, res.Status.Namespace)
                err = helpers.CopyReservationSecrets(ctx, r.client, readyNsName, res, r.log)
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Error(err, "could not copy reservation secrets", "namespace", readyNsName)
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = r.client.Update(ctx, &amp;nsObject)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err, "could not update namespace", "namespace", readyNsName)
                return err
        }</span>

        // Add rolebinding to the namespace only after it has been owned by the CRD.
        // We need to skip this on minikube
        <span class="cov8" title="1">if err := r.addRoleBindings(ctx, &amp;nsObject, r.client); err != nil </span><span class="cov0" title="0">{
                r.log.Error(err, "could not apply rolebindings for namespace", "namespace", readyNsName)
                return err
        }</span>

        <span class="cov8" title="1">totalSuccessfulPoolReservationsCountMetrics.With(prometheus.Labels{"pool": res.Spec.Pool}).Inc()

        return nil</span>
}

func getExpirationTime(res *crd.NamespaceReservation) (metav1.Time, error) <span class="cov8" title="1">{
        duration, err := parseDurationTime(*res.Spec.Duration)
        if err != nil </span><span class="cov0" title="0">{
                return metav1.Time{}, err
        }</span>

        <span class="cov8" title="1">if duration == 0 </span><span class="cov0" title="0">{
                return metav1.Time{Time: time.Now()}, err // If these are not error states, we want to return nil
        }</span>

        <span class="cov8" title="1">return metav1.Time{Time: res.CreationTimestamp.Time.Add(duration)}, err</span> // Same here
}

func (r *NamespaceReservationReconciler) verifyClowdEnvForReadyNs(ctx context.Context, readyNsName string) error <span class="cov8" title="1">{
        ready, _, err := helpers.GetClowdEnv(ctx, r.client, readyNsName)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error(err, "could not retrieve Clowdenvironment", "namespace", readyNsName)
        }</span>
        <span class="cov8" title="1">if !ready </span><span class="cov0" title="0">{
                return fmt.Errorf("ClowdEnvironment is not ready for namespace [%s]: %w", readyNsName, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *NamespaceReservationReconciler) addRoleBindings(ctx context.Context, ns *core.Namespace, client client.Client) error <span class="cov8" title="1">{
        // TODO: hard-coded list of users for now, but will want to do graphql queries later
        roleNames := []string{"admin"}

        for _, roleName := range roleNames </span><span class="cov8" title="1">{
                binding := rbac.RoleBinding{
                        RoleRef: rbac.RoleRef{
                                APIGroup: "rbac.authorization.k8s.io",
                                Kind:     "ClusterRole",
                                Name:     roleName,
                        },
                        Subjects: []rbac.Subject{},
                }

                for name, kind := range hardCodedUserList() </span><span class="cov8" title="1">{
                        r.log.Info(fmt.Sprintf("Creating rolebinding %s for %s: %s", roleName, kind, name), "namespace", ns.Name)
                        binding.Subjects = append(binding.Subjects, rbac.Subject{
                                APIGroup: "rbac.authorization.k8s.io",
                                Kind:     kind,
                                Name:     name,
                        })
                }</span>

                <span class="cov8" title="1">binding.Subjects = append(binding.Subjects, rbac.Subject{
                        Kind:      "ServiceAccount",
                        Name:      "ephemeral-bot",
                        Namespace: "ephemeral-base",
                })

                binding.SetName(fmt.Sprintf("%s-%s", ns.Name, roleName))
                binding.SetNamespace(ns.Name)

                if err := client.Create(ctx, &amp;binding); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func hardCodedUserList() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "ephemeral-users":      "Group",
                "system:authenticated": "Group",
        }
}</span>

func parseDurationTime(duration string) (time.Duration, error) <span class="cov8" title="1">{
        var durationTime time.Duration
        var err error

        if duration != "" </span><span class="cov8" title="1">{
                durationTime, err = time.ParseDuration(duration)
        }</span> else<span class="cov8" title="1"> {
                // Defaults to 1 hour if not specified in spec
                durationTime, err = time.ParseDuration("1h")
        }</span>

        <span class="cov8" title="1">return durationTime, err</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controllers

import (
        "context"
        "time"

        crd "github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1"
        "github.com/go-logr/logr"
        "github.com/prometheus/client_golang/prometheus"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type Poller struct {
        client             client.Client
        activeReservations map[string]metav1.Time
        log                logr.Logger
}

const PollCycle time.Duration = 10

func (p *Poller) Poll() <span class="cov8" title="1">{
        ctx := context.Background()
        p.log.Info("Starting poller...")

        // Wait a period before beginning to poll
        // TODO workaround due to checking k8s objects too soon - revisit
        time.Sleep(time.Duration(30 * time.Second))

        p.log.Info("Populating poller with active reservations")
        if err := p.populateActiveReservations(ctx); err != nil </span><span class="cov0" title="0">{
                p.log.Error(err, "Unable to populate pool with active reservations")
                return
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                // Check for expired reservations
                for k, v := range p.activeReservations </span><span class="cov8" title="1">{
                        if !p.namespaceIsExpired(v) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">delete(p.activeReservations, k)

                        res := crd.NamespaceReservation{}
                        if err := p.client.Get(ctx, types.NamespacedName{Name: k}, &amp;res); err != nil </span><span class="cov0" title="0">{
                                p.log.Error(err, "Unable to retrieve reservation")
                        }</span>

                        <span class="cov8" title="1">if err := p.client.Delete(ctx, &amp;res); err != nil </span><span class="cov0" title="0">{
                                p.log.Error(err, "Unable to delete reservation", "namespace", res.Status.Namespace)
                        }</span> else<span class="cov8" title="1"> {
                                p.log.Info("deleting expired reservation", "namespace", res.Status.Namespace)
                        }</span>

                        <span class="cov8" title="1">activeReservationTotalMetrics.With(prometheus.Labels{"controller": "namespacereservation"}).Set(float64(len(p.activeReservations)))</span>
                }

                <span class="cov8" title="1">time.Sleep(time.Duration(PollCycle * time.Second))</span>
        }
}

func (p *Poller) populateActiveReservations(ctx context.Context) error <span class="cov8" title="1">{
        resList, err := p.getExistingReservations(ctx)
        if err != nil </span><span class="cov0" title="0">{
                p.log.Error(err, "Error retrieving list of reservations")
                return err
        }</span>

        <span class="cov8" title="1">for _, res := range resList.Items </span><span class="cov8" title="1">{
                if res.Status.State == "active" </span><span class="cov8" title="1">{
                        p.activeReservations[res.Name] = res.Status.Expiration
                        p.log.Info("Added active reservation to poller", "res-name", res.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (p *Poller) getExistingReservations(ctx context.Context) (*crd.NamespaceReservationList, error) <span class="cov8" title="1">{
        resList := crd.NamespaceReservationList{}
        err := p.client.List(ctx, &amp;resList)
        if err != nil </span><span class="cov0" title="0">{
                p.log.Error(err, "Cannot get reservations")
                return &amp;resList, err
        }</span>
        <span class="cov8" title="1">return &amp;resList, nil</span>

}

func (p *Poller) namespaceIsExpired(expiration metav1.Time) bool <span class="cov8" title="1">{
        remainingTime := time.Until(expiration.Time)
        if !expiration.IsZero() &amp;&amp; remainingTime &lt;= 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package controllers

import (
        _ "embed"
        "os"

        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"

        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"

        clowder "github.com/RedHatInsights/clowder/apis/cloud.redhat.com/v1alpha1"
        frontend "github.com/RedHatInsights/frontend-operator/api/v1alpha1"
        configv1 "github.com/openshift/api/config/v1"
        projectv1 "github.com/openshift/api/project/v1"
        "github.com/prometheus/client_golang/prometheus"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        crd "github.com/RedHatInsights/ephemeral-namespace-operator/apis/cloud.redhat.com/v1alpha1"
)

var (
        scheme   = runtime.NewScheme()
        setupLog = ctrl.Log.WithName("setup")
)

func init() <span class="cov8" title="1">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))
        utilruntime.Must(clowder.AddToScheme(scheme))
        utilruntime.Must(frontend.AddToScheme(scheme))
        utilruntime.Must(projectv1.AddToScheme(scheme))
        utilruntime.Must(configv1.AddToScheme(scheme))
        utilruntime.Must(crd.AddToScheme(scheme))
        //+kubebuilder:scaffold:scheme
}</span>

//go:embed version.txt
var Version string

func Run(metricsAddr string, probeAddr string, enableLeaderElection bool) <span class="cov0" title="0">{
        enoVersion.With(prometheus.Labels{"version": Version}).Inc()

        mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme: scheme,
                Metrics: metricsserver.Options{
                        BindAddress: metricsAddr,
                },
                HealthProbeBindAddress: probeAddr,
                LeaderElection:         enableLeaderElection,
                LeaderElectionID:       "2ee9ac64.cloud.redhat.com",
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">poller := Poller{
                client:             mgr.GetClient(),
                activeReservations: make(map[string]metav1.Time),
                log:                ctrl.Log.WithName("Poller"),
        }

        if err = (&amp;NamespaceReservationReconciler{
                client: mgr.GetClient(),
                scheme: mgr.GetScheme(),
                poller: &amp;poller,
                log:    ctrl.Log.WithName("controllers").WithName("ReservationController"),
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "NamespaceReservation")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err = (&amp;NamespacePoolReconciler{
                client: mgr.GetClient(),
                scheme: mgr.GetScheme(),
                log:    ctrl.Log.WithName("controllers").WithName("NamespacePoolController"),
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "NamespacePool")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err = (&amp;ClowdenvironmentReconciler{
                client: mgr.GetClient(),
                scheme: mgr.GetScheme(),
                log:    ctrl.Log.WithName("controllers").WithName("ClowdEnvController"),
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "Clowdenvironment")
                os.Exit(1)
        }</span>
        //+kubebuilder:scaffold:builder

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">go poller.Poll()

        setupLog.Info("starting manager")
        if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "flag"

        controllers "github.com/RedHatInsights/ephemeral-namespace-operator/controllers/cloud.redhat.com"
        _ "k8s.io/client-go/plugin/pkg/client/auth"

        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        //+kubebuilder:scaffold:imports
)

func main() <span class="cov0" title="0">{
        var metricsAddr string
        var enableLeaderElection bool
        var probeAddr string
        flag.StringVar(&amp;metricsAddr, "metrics-bind-address", ":9000", "The address the metric endpoint binds to.")
        flag.StringVar(&amp;probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        flag.BoolVar(&amp;enableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")
        opts := zap.Options{
                Development: true,
        }
        opts.BindFlags(flag.CommandLine)
        flag.Parse()

        ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))

        controllers.Run(metricsAddr, probeAddr, enableLeaderElection)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
